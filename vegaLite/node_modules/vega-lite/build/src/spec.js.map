{"version":3,"file":"spec.js","sourceRoot":"","sources":["../../src/spec.ts"],"names":[],"mappings":"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","sourcesContent":["import {Config} from './config';\nimport {Data} from './data';\nimport * as vlEncoding from './encoding';\nimport {Encoding, EncodingWithFacet, forEach} from './encoding';\nimport {FacetMapping} from './facet';\nimport {Field, FieldDef, RepeatRef} from './fielddef';\nimport * as log from './log';\nimport {AnyMark, isPrimitiveMark, Mark, MarkDef} from './mark';\nimport {Projection} from './projection';\nimport {Repeat} from './repeat';\nimport {Resolve} from './resolve';\nimport {SelectionDef} from './selection';\nimport {stack} from './stack';\nimport {TitleParams} from './title';\nimport {ConcatLayout, Datasets, GenericCompositionLayout, TopLevelProperties} from './toplevelprops';\nimport {Transform} from './transform';\nimport {Dict, hash, vals} from './util';\n\nexport type TopLevel<S extends BaseSpec> = S &\n  TopLevelProperties & {\n    /**\n     * URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v3.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.\n     * @format uri\n     */\n    $schema?: string;\n\n    /**\n     * Vega-Lite configuration object.  This property can only be defined at the top-level of a specification.\n     */\n    config?: Config;\n\n    /**\n     * A global data store for named datasets. This is a mapping from names to inline datasets.\n     * This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property.\n     */\n    datasets?: Datasets;\n\n    /**\n     * Optional metadata that will be passed to Vega.\n     * This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata.\n     */\n    usermeta?: object;\n  };\n\nexport type BaseSpec = Partial<DataMixins> & {\n  /**\n   * Title for the plot.\n   */\n  title?: string | TitleParams;\n\n  /**\n   * Name of the visualization for later reference.\n   */\n  name?: string;\n\n  /**\n   * Description of this mark for commenting purpose.\n   */\n  description?: string;\n\n  /**\n   * An object describing the data source\n   */\n  data?: Data;\n\n  /**\n   * An array of data transformations such as filter and new field calculation.\n   */\n  transform?: Transform[];\n};\n\nexport interface DataMixins {\n  /**\n   * An object describing the data source\n   */\n  data: Data;\n}\n\n// TODO(https://github.com/vega/vega-lite/issues/2503): Make this generic so we can support some form of top-down sizing.\nexport interface LayoutSizeMixins {\n  /**\n   * The width of a visualization.\n   *\n   * __Default value:__ This will be determined by the following rules:\n   *\n   * - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type is `\"fit\"` or its x-channel has a [continuous scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the width will be the value of [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).\n   * - For x-axis with a band or point scale: if [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value or unspecified, the width is [determined by the range step, paddings, and the cardinality of the field mapped to x-channel](https://vega.github.io/vega-lite/docs/scale.html#band).   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).\n   * - If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](https://vega.github.io/vega-lite/docs/size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.\n   *\n   * __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view.\n   *\n   * __See also:__ The documentation for [width and height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.\n   */\n  width?: number;\n\n  /**\n   * The height of a visualization.\n   *\n   * __Default value:__\n   * - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type is `\"fit\"` or its y-channel has a [continuous scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the height will be the value of [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).\n   * - For y-axis with a band or point scale: if [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value or unspecified, the height is [determined by the range step, paddings, and the cardinality of the field mapped to y-channel](https://vega.github.io/vega-lite/docs/scale.html#band). Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).\n   * - If no field is mapped to `y` channel, the `height` will be the value of `rangeStep`.\n   *\n   * __Note__: For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view.\n   *\n   * __See also:__ The documentation for [width and height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.\n   */\n  height?: number;\n}\n\nexport interface GenericUnitSpec<E extends Encoding<any>, M> extends BaseSpec, LayoutSizeMixins {\n  /**\n   * A string describing the mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"rule\"`, `\"geoshape\"`, and `\"text\"`) or a [mark definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).\n   */\n  mark: M;\n\n  /**\n   * A key-value mapping between encoding channels and definition of fields.\n   */\n  encoding?: E;\n\n  /**\n   * An object defining properties of geographic projection, which will be applied to `shape` path for `\"geoshape\"` marks\n   * and to `latitude` and `\"longitude\"` channels for other marks.\n   */\n  projection?: Projection;\n\n  /**\n   * A key-value mapping between selection names and definitions.\n   */\n  selection?: {[name: string]: SelectionDef};\n}\n\nexport type NormalizedUnitSpec = GenericUnitSpec<Encoding<string | RepeatRef>, Mark | MarkDef>;\n\n/**\n * Unit spec that can have a composite mark.\n */\nexport type CompositeUnitSpec = GenericUnitSpec<Encoding<string | RepeatRef>, AnyMark>;\n\n/**\n * Unit spec that can have a composite mark and row or column channels.\n */\nexport type FacetedCompositeUnitSpec = GenericUnitSpec<EncodingWithFacet<string | RepeatRef>, AnyMark>;\n\nexport interface GenericLayerSpec<U extends GenericUnitSpec<any, any>> extends BaseSpec, LayoutSizeMixins {\n  /**\n   * Layer or single view specifications to be layered.\n   *\n   * __Note__: Specifications inside `layer` cannot use `row` and `column` channels as layering facet specifications is not allowed. Instead, use the [facet operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a facet.\n   */\n  layer: (GenericLayerSpec<U> | U)[];\n\n  /**\n   * Scale, axis, and legend resolutions for layers.\n   */\n  resolve?: Resolve;\n}\n\n/**\n * Layer Spec with encoding and projection\n */\nexport interface ExtendedLayerSpec extends GenericLayerSpec<CompositeUnitSpec> {\n  /**\n   * A shared key-value mapping between encoding channels and definition of fields in the underlying layers.\n   */\n  encoding?: Encoding<string | RepeatRef>;\n\n  /**\n   * An object defining properties of the geographic projection shared by underlying layers.\n   */\n  projection?: Projection;\n}\n\nexport type NormalizedLayerSpec = GenericLayerSpec<NormalizedUnitSpec>;\n\nexport interface GenericFacetSpec<U extends GenericUnitSpec<any, any>, L extends GenericLayerSpec<any>>\n  extends BaseSpec,\n    GenericCompositionLayout {\n  /**\n   * An object that describes mappings between `row` and `column` channels and their field definitions.\n   */\n  facet: FacetMapping<string | RepeatRef>;\n\n  /**\n   * A specification of the view that gets faceted.\n   */\n  spec: L | U;\n  // TODO: replace this with GenericSpec<U> once we support all cases;\n\n  /**\n   * Scale, axis, and legend resolutions for facets.\n   */\n  resolve?: Resolve;\n}\n\nexport type NormalizedFacetSpec = GenericFacetSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport interface GenericRepeatSpec<U extends GenericUnitSpec<any, any>, L extends GenericLayerSpec<any>>\n  extends BaseSpec,\n    GenericCompositionLayout {\n  /**\n   * An object that describes what fields should be repeated into views that are laid out as a `row` or `column`.\n   */\n  repeat: Repeat;\n\n  spec: GenericSpec<U, L>;\n\n  /**\n   * Scale and legend resolutions for repeated charts.\n   */\n  resolve?: Resolve;\n}\n\nexport type NormalizedRepeatSpec = GenericRepeatSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport interface GenericVConcatSpec<U extends GenericUnitSpec<any, any>, L extends GenericLayerSpec<any>>\n  extends BaseSpec,\n    ConcatLayout {\n  /**\n   * A list of views that should be concatenated and put into a column.\n   */\n  vconcat: (GenericSpec<U, L>)[];\n\n  /**\n   * Scale, axis, and legend resolutions for vertically concatenated charts.\n   */\n  resolve?: Resolve;\n}\n\nexport interface GenericHConcatSpec<U extends GenericUnitSpec<any, any>, L extends GenericLayerSpec<any>>\n  extends BaseSpec,\n    ConcatLayout {\n  /**\n   * A list of views that should be concatenated and put into a row.\n   */\n  hconcat: (GenericSpec<U, L>)[];\n\n  /**\n   * Scale, axis, and legend resolutions for horizontally concatenated charts.\n   */\n  resolve?: Resolve;\n}\n\nexport type NormalizedConcatSpec =\n  | GenericVConcatSpec<NormalizedUnitSpec, NormalizedLayerSpec>\n  | GenericHConcatSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport type GenericSpec<U extends GenericUnitSpec<any, any>, L extends GenericLayerSpec<any>> =\n  | U\n  | L\n  | GenericFacetSpec<U, L>\n  | GenericRepeatSpec<U, L>\n  | GenericVConcatSpec<U, L>\n  | GenericHConcatSpec<U, L>;\n\nexport type NormalizedSpec = GenericSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport type TopLevelFacetedUnitSpec = TopLevel<FacetedCompositeUnitSpec> & DataMixins;\nexport type TopLevelFacetSpec = TopLevel<GenericFacetSpec<FacetedCompositeUnitSpec, ExtendedLayerSpec>> & DataMixins;\n\nexport type TopLevelSpec =\n  | TopLevelFacetedUnitSpec\n  | TopLevelFacetSpec\n  | TopLevel<ExtendedLayerSpec>\n  | TopLevel<GenericRepeatSpec<FacetedCompositeUnitSpec, ExtendedLayerSpec>>\n  | TopLevel<GenericVConcatSpec<FacetedCompositeUnitSpec, ExtendedLayerSpec>>\n  | TopLevel<GenericHConcatSpec<FacetedCompositeUnitSpec, ExtendedLayerSpec>>;\n\n/* Custom type guards */\n\nexport function isFacetSpec(spec: BaseSpec): spec is GenericFacetSpec<any, any> {\n  return spec['facet'] !== undefined;\n}\n\nexport function isUnitSpec(spec: BaseSpec): spec is FacetedCompositeUnitSpec | NormalizedUnitSpec {\n  return !!spec['mark'];\n}\n\nexport function isLayerSpec(spec: BaseSpec): spec is GenericLayerSpec<any> {\n  return spec['layer'] !== undefined;\n}\n\nexport function isRepeatSpec(spec: BaseSpec): spec is GenericRepeatSpec<any, any> {\n  return spec['repeat'] !== undefined;\n}\n\nexport function isConcatSpec(spec: BaseSpec): spec is GenericVConcatSpec<any, any> | GenericHConcatSpec<any, any> {\n  return isVConcatSpec(spec) || isHConcatSpec(spec);\n}\n\nexport function isVConcatSpec(spec: BaseSpec): spec is GenericVConcatSpec<any, any> {\n  return spec['vconcat'] !== undefined;\n}\n\nexport function isHConcatSpec(spec: BaseSpec): spec is GenericHConcatSpec<any, any> {\n  return spec['hconcat'] !== undefined;\n}\n\nexport {normalizeTopLevelSpec as normalize} from './normalize';\n\n// TODO: add vl.spec.validate & move stuff from vl.validate to here\n\n/* Accumulate non-duplicate fieldDefs in a dictionary */\nfunction accumulate(dict: any, defs: FieldDef<Field>[]): any {\n  defs.forEach(fieldDef => {\n    // Consider only pure fieldDef properties (ignoring scale, axis, legend)\n    const pureFieldDef = ['field', 'type', 'value', 'timeUnit', 'bin', 'aggregate'].reduce((f, key) => {\n      if (fieldDef[key] !== undefined) {\n        f[key] = fieldDef[key];\n      }\n      return f;\n    }, {});\n    const key = hash(pureFieldDef);\n    dict[key] = dict[key] || fieldDef;\n  });\n  return dict;\n}\n\n/* Recursively get fieldDefs from a spec, returns a dictionary of fieldDefs */\nfunction fieldDefIndex<T>(spec: GenericSpec<any, any>, dict: Dict<FieldDef<T>> = {}): Dict<FieldDef<T>> {\n  // FIXME(https://github.com/vega/vega-lite/issues/2207): Support fieldDefIndex for repeat\n  if (isLayerSpec(spec)) {\n    spec.layer.forEach(layer => {\n      if (isUnitSpec(layer)) {\n        accumulate(dict, vlEncoding.fieldDefs(layer.encoding));\n      } else {\n        fieldDefIndex(layer, dict);\n      }\n    });\n  } else if (isFacetSpec(spec)) {\n    accumulate(dict, vlEncoding.fieldDefs(spec.facet));\n    fieldDefIndex(spec.spec, dict);\n  } else if (isRepeatSpec(spec)) {\n    fieldDefIndex(spec.spec, dict);\n  } else if (isConcatSpec(spec)) {\n    const childSpec = isVConcatSpec(spec) ? spec.vconcat : spec.hconcat;\n    childSpec.forEach(child => fieldDefIndex(child, dict));\n  } else {\n    // Unit Spec\n    accumulate(dict, vlEncoding.fieldDefs(spec.encoding));\n  }\n  return dict;\n}\n\n/* Returns all non-duplicate fieldDefs in a spec in a flat array */\nexport function fieldDefs(spec: GenericSpec<any, any>): FieldDef<any>[] {\n  return vals(fieldDefIndex(spec));\n}\n\nexport function isStacked(spec: TopLevel<FacetedCompositeUnitSpec>, config?: Config): boolean {\n  config = config || spec.config;\n  if (isPrimitiveMark(spec.mark)) {\n    return stack(spec.mark, spec.encoding, config ? config.stack : undefined) !== null;\n  }\n  return false;\n}\n\n/**\n * Takes a spec and returns a list of fields used in encoding\n */\nexport function usedFields(spec: NormalizedSpec): string[] {\n  if (isFacetSpec(spec) || isRepeatSpec(spec)) {\n    return usedFieldsSingle(spec);\n  }\n  if (isLayerSpec(spec)) {\n    return usedFieldsLayered(spec);\n  }\n  if (isUnitSpec(spec)) {\n    return usedFieldsUnit(spec);\n  }\n  throw new Error(log.message.INVALID_SPEC);\n}\n\nfunction usedFieldsUnit(spec: NormalizedUnitSpec): string[] {\n  const fields: string[] = [];\n  forEach(spec.encoding, (fieldDef, channel) => {\n    fields.push(fieldDef.field);\n  });\n  return fields;\n}\n\nfunction usedFieldsLayered(spec: NormalizedLayerSpec): string[] {\n  let fields: string[] = [];\n  spec.layer.map(subspec => {\n    fields = fields.concat(usedFields(subspec));\n  });\n  return fields;\n}\n\nfunction usedFieldsSingle(spec: NormalizedFacetSpec | NormalizedRepeatSpec): string[] {\n  return usedFields(spec.spec);\n}\n"]}