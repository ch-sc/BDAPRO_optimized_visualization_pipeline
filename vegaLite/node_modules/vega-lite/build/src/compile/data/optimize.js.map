{"version":3,"file":"optimize.js","sourceRoot":"","sources":["../../../../src/compile/data/optimize.ts"],"names":[],"mappings":"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","sourcesContent":["import {MAIN} from '../../data';\nimport * as log from '../../log';\nimport {flatten, keys} from '../../util';\nimport {AggregateNode} from './aggregate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {checkLinks} from './debug';\nimport {FacetNode} from './facet';\nimport {ParseNode} from './formatparse';\nimport {DataComponent} from './index';\nimport {BottomUpOptimizer, TopDownOptimizer} from './optimizer';\nimport * as optimizers from './optimizers';\nimport {MergeIdenticalNodes} from './optimizers';\nimport {StackNode} from './stack';\nimport {WindowTransformNode} from './window';\n\nexport const FACET_SCALE_PREFIX = 'scale_';\nexport const MAX_OPTIMIZATION_RUNS = 5;\n\n/**\n * Clones the subtree and ignores output nodes except for the leaves, which are renamed.\n */\nfunction cloneSubtree(facet: FacetNode) {\n  function clone(node: DataFlowNode): DataFlowNode[] {\n    if (!(node instanceof FacetNode)) {\n      const copy = node.clone();\n\n      if (copy instanceof OutputNode) {\n        const newName = FACET_SCALE_PREFIX + copy.getSource();\n        copy.setSource(newName);\n\n        facet.model.component.data.outputNodes[newName] = copy;\n      } else if (copy instanceof AggregateNode || copy instanceof StackNode || copy instanceof WindowTransformNode) {\n        copy.addDimensions(facet.fields);\n      }\n      flatten(node.children.map(clone)).forEach((n: DataFlowNode) => (n.parent = copy));\n\n      return [copy];\n    }\n\n    return flatten(node.children.map(clone));\n  }\n  return clone;\n}\n\n/**\n * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.\n * After moving down the facet node, make a copy of the subtree and make it a child of the main output.\n */\nfunction moveFacetDown(node: DataFlowNode) {\n  if (node instanceof FacetNode) {\n    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {\n      // move down until we hit a fork or output node\n      const child = node.children[0];\n\n      if (child instanceof AggregateNode || child instanceof StackNode || child instanceof WindowTransformNode) {\n        child.addDimensions(node.fields);\n      }\n\n      child.swapWithParent();\n      moveFacetDown(node);\n    } else {\n      // move main to facet\n\n      const facetMain = node.model.component.data.main;\n      moveMainDownToFacet(facetMain);\n\n      // replicate the subtree and place it before the facet's main node\n      const cloner = cloneSubtree(node);\n      const copy: DataFlowNode[] = flatten(node.children.map(cloner));\n      for (const c of copy) {\n        c.parent = facetMain;\n      }\n    }\n  } else {\n    node.children.map(moveFacetDown);\n  }\n}\n\nfunction moveMainDownToFacet(node: DataFlowNode) {\n  if (node instanceof OutputNode && node.type === MAIN) {\n    if (node.numChildren() === 1) {\n      const child = node.children[0];\n      if (!(child instanceof FacetNode)) {\n        child.swapWithParent();\n        moveMainDownToFacet(node);\n      }\n    }\n  }\n}\n\n/**\n * Remove nodes that are not required starting from a root.\n */\nclass RemoveUnnecessaryNodes extends TopDownOptimizer {\n  public run(node: DataFlowNode): boolean {\n    // remove output nodes that are not required\n    if (node instanceof OutputNode && !node.isRequired()) {\n      this.setMutated();\n      node.remove();\n    }\n    for (const child of node.children) {\n      this.run(child);\n    }\n\n    return this.mutatedFlag;\n  }\n}\n\n/**\n * Return all leaf nodes.\n */\nfunction getLeaves(roots: DataFlowNode[]) {\n  const leaves: DataFlowNode[] = [];\n  function append(node: DataFlowNode) {\n    if (node.numChildren() === 0) {\n      leaves.push(node);\n    } else {\n      node.children.forEach(append);\n    }\n  }\n\n  roots.forEach(append);\n  return leaves;\n}\n\n/**\n * Inserts an Intermediate ParseNode containing all non-conflicting Parse fields and removes the empty ParseNodes\n */\nexport class MergeParse extends BottomUpOptimizer {\n  public run(node: DataFlowNode): optimizers.OptimizerFlags {\n    const parent = node.parent;\n    const parseChildren = parent.children.filter((x): x is ParseNode => x instanceof ParseNode);\n\n    if (parseChildren.length > 1) {\n      const commonParse = {};\n      for (const parseNode of parseChildren) {\n        const parse = parseNode.parse;\n        for (const k of keys(parse)) {\n          if (commonParse[k] === undefined) {\n            commonParse[k] = parse[k];\n          } else if (commonParse[k] !== parse[k]) {\n            delete commonParse[k];\n          }\n        }\n      }\n      if (keys(commonParse).length !== 0) {\n        this.setMutated();\n        const mergedParseNode = new ParseNode(parent, commonParse);\n        for (const parseNode of parseChildren) {\n          for (const key of keys(commonParse)) {\n            delete parseNode.parse[key];\n          }\n          parent.removeChild(parseNode);\n          parseNode.parent = mergedParseNode;\n          if (keys(parseNode.parse).length === 0) {\n            parseNode.remove();\n          }\n        }\n      }\n    }\n    this.setContinue();\n    return this.flags;\n  }\n}\n\nexport function isTrue(x: boolean) {\n  return x;\n}\n\n/**\n * Run the specified optimizer on the provided nodes.\n *\n * @param optimizer The optimizer to run.\n * @param nodes A set of nodes to optimize.\n * @param flag Flag that will be or'ed with return valued from optimization calls to the nodes.\n */\nfunction runOptimizer(\n  optimizer: typeof BottomUpOptimizer | typeof TopDownOptimizer,\n  nodes: DataFlowNode[],\n  flag: boolean\n) {\n  const flags = nodes.map(node => {\n    const optimizerInstance = new optimizer();\n    if (optimizerInstance instanceof BottomUpOptimizer) {\n      return optimizerInstance.optimizeNextFromLeaves(node);\n    } else {\n      return optimizerInstance.run(node);\n    }\n  });\n  return flags.some(isTrue) || flag;\n}\n\nfunction optimizationDataflowHelper(dataComponent: DataComponent) {\n  let roots = dataComponent.sources;\n  let mutatedFlag = false;\n\n  // mutatedFlag should always be on the right side otherwise short circuit logic might cause the mutating method to not execute\n  mutatedFlag = runOptimizer(RemoveUnnecessaryNodes, roots, mutatedFlag);\n\n  // remove source nodes that don't have any children because they also don't have output nodes\n  roots = roots.filter(r => r.numChildren() > 0);\n\n  mutatedFlag = runOptimizer(optimizers.RemoveUnusedSubtrees, getLeaves(roots), mutatedFlag);\n\n  roots = roots.filter(r => r.numChildren() > 0);\n\n  mutatedFlag = runOptimizer(optimizers.MoveParseUp, getLeaves(roots), mutatedFlag);\n\n  mutatedFlag = runOptimizer(optimizers.RemoveDuplicateTimeUnits, getLeaves(roots), mutatedFlag);\n\n  mutatedFlag = runOptimizer(MergeParse, getLeaves(roots), mutatedFlag);\n\n  mutatedFlag = runOptimizer(MergeIdenticalNodes, roots, mutatedFlag);\n\n  dataComponent.sources = roots;\n\n  return mutatedFlag;\n}\n\n/**\n * Optimizes the dataflow of the passed in data component.\n */\nexport function optimizeDataflow(data: DataComponent) {\n  // check before optimizations\n  checkLinks(data.sources);\n\n  let firstPassCounter = 0;\n  let secondPassCounter = 0;\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data)) {\n      break;\n    }\n    firstPassCounter++;\n  }\n\n  // move facets down and make a copy of the subtree so that we can have scales at the top level\n  data.sources.map(moveFacetDown);\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data)) {\n      break;\n    }\n    secondPassCounter++;\n  }\n\n  // check after optimizations\n  checkLinks(data.sources);\n\n  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {\n    log.warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);\n  }\n}\n"]}