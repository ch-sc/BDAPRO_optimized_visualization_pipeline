{"version":3,"file":"optimizers.js","sourceRoot":"","sources":["../../../../src/compile/data/optimizers.ts"],"names":[],"mappings":"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","sourcesContent":["import {fieldIntersection, keys} from '../../util';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {ParseNode} from './formatparse';\nimport {BottomUpOptimizer, TopDownOptimizer} from './optimizer';\nimport {SourceNode} from './source';\nimport {TimeUnitNode} from './timeunit';\n\nexport interface OptimizerFlags {\n  /**\n   * If true, iteration continues\n   */\n  continueFlag: boolean;\n  /**\n   * If true, the tree has been mutated by the function\n   */\n  mutatedFlag: boolean;\n}\n\n/**\n * Start optimization path at the leaves. Useful for merging up or removing things.\n *\n * If the callback returns true, the recursion continues.\n */\nexport function iterateFromLeaves(f: (node: DataFlowNode) => OptimizerFlags) {\n  function optimizeNextFromLeaves(node: DataFlowNode): boolean {\n    if (node instanceof SourceNode) {\n      return false;\n    }\n\n    const next = node.parent;\n    const {continueFlag, mutatedFlag} = f(node);\n    let childFlag = false;\n    if (continueFlag) {\n      childFlag = optimizeNextFromLeaves(next);\n    }\n    return mutatedFlag || childFlag;\n  }\n\n  return optimizeNextFromLeaves;\n}\n\n/**\n * Move parse nodes up to forks.\n */\nexport class MoveParseUp extends BottomUpOptimizer {\n  public run(node: DataFlowNode): OptimizerFlags {\n    const parent = node.parent;\n    // move parse up by merging or swapping\n    if (node instanceof ParseNode) {\n      if (parent instanceof SourceNode) {\n        return this.flags;\n      }\n\n      if (parent.numChildren() > 1) {\n        // don't move parse further up but continue with parent.\n        this.setContinue();\n        return this.flags;\n      }\n\n      if (parent instanceof ParseNode) {\n        this.setMutated();\n        parent.merge(node);\n      } else {\n        // don't swap with nodes that produce something that the parse node depends on (e.g. lookup)\n        if (fieldIntersection(parent.producedFields(), node.dependentFields())) {\n          this.setContinue();\n          return this.flags;\n        }\n        this.setMutated();\n        node.swapWithParent();\n      }\n    }\n    this.setContinue();\n    return this.flags;\n  }\n}\n\n/**\n * Merge identical nodes at forks by comparing hashes.\n *\n * Does not need to iterate from leaves so we implement this with recursion as it's a bit simpler.\n */\nexport class MergeIdenticalNodes extends TopDownOptimizer {\n  public mergeNodes(parent: DataFlowNode, nodes: DataFlowNode[]) {\n    const mergedNode = nodes.shift();\n    for (const node of nodes) {\n      parent.removeChild(node);\n      node.parent = mergedNode;\n      node.remove();\n    }\n  }\n\n  public run(node: DataFlowNode): boolean {\n    const hashes = node.children.map(x => x.hash());\n    const buckets: {hash?: DataFlowNode[]} = {};\n\n    for (let i = 0; i < hashes.length; i++) {\n      if (buckets[hashes[i]] === undefined) {\n        buckets[hashes[i]] = [node.children[i]];\n      } else {\n        buckets[hashes[i]].push(node.children[i]);\n      }\n    }\n\n    for (const k of keys(buckets)) {\n      if (buckets[k].length > 1) {\n        this.setMutated();\n        this.mergeNodes(node, buckets[k]);\n      }\n    }\n    for (const child of node.children) {\n      this.run(child);\n    }\n    return this.mutatedFlag;\n  }\n}\n\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\nexport class RemoveUnusedSubtrees extends BottomUpOptimizer {\n  public run(node: DataFlowNode): OptimizerFlags {\n    if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {\n      // no need to continue with parent because it is output node or will have children (there was a fork)\n      return this.flags;\n    } else {\n      this.setMutated();\n      node.remove();\n    }\n    return this.flags;\n  }\n}\n\n/**\n * Removes duplicate time unit nodes (as determined by the name of the\n * output field) that may be generated due to selections projected over\n * time units.\n */\n\nexport class RemoveDuplicateTimeUnits extends BottomUpOptimizer {\n  private fields = {};\n  public run(node: DataFlowNode): OptimizerFlags {\n    this.setContinue();\n    if (node instanceof TimeUnitNode) {\n      const pfields = node.producedFields();\n      const dupe = keys(pfields).every(k => !!this.fields[k]);\n\n      if (dupe) {\n        this.setMutated();\n        node.remove();\n      } else {\n        this.fields = {...this.fields, ...pfields};\n      }\n    }\n    return this.flags;\n  }\n}\n"]}